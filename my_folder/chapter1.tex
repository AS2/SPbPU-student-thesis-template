\chapter{Определения и постановка задачи} \label{ch1}

В данной главе представлено формальное определение решаемой задачи, которое поможет не 
только лучше понимать суть решаемой проблемы, но и определит возможные сценарии её решения.
Однако невозможно сформулировать задачу, не понимая базовых понятий, из которых она состоит.
С этих понятий и начнем.

\section{Формальные определения} \label{ch1:sec1}

\subsection{Определение агента} \label{ch1:sec1:subsec1}

\textbf{Агент} - программа, самостоятельно выполняющую поставленную пользователем задачу, 
используя предоставленные ей инструменты и основываясь на состоянии окружения: 
инструменты для оценки состояния окружения принято называть \textit{сенсорами}, а инструменты 
для работы и взимодействия со средой - \textit{актуаторами} \cite{AIAMA}.

Стоит отметить, что в данное понятие не вкладываются критерии об ``интеллектуальности'' - 
хотя это важно: \textbf{рациональным (или интеллектуальным) агентом} принято называть агента
выполняющий задачу ``эффективно'', ``наилучшим образом''. ``Наилучшее'' решение определяется
уже вводимыми разработчиками метриками. В рамках текущей работы будем использовать эти два
термина как синонимы.

Такое широкое определение позволяет формализовать понятие агента разными способами, 
каждое из которых остается не только верным, но и удобным для исследования в определенных
прадигмах. Так, например, одним из самых популярных формальных определений агента, 
которое часто используется в области обучения с подкреплением (Reinforcment learning),
описывается такой тройкой \cite{Sutton1998}:
\begin{equation}
    Agent = \{\mathcal{P}, \mathcal{A}, \mathcal{S}\} \label{eq1}
\end{equation}
Определим понятия тройки \ref{eq1}: 
\begin{itemize}
    \item $Agent$ - непосредственно агент;
    \item $\mathcal{P}: (s_{t} \times ... \times s_{t-k}) \rightarrow a, s_{i} \in \mathcal{S}, a \in \mathcal{A}, k \in 0..t$ - политика (Policy), формирующие процесс принятия решения агентом;
    \item $\mathcal{A}$ - набор допустимых действий агента, актуаторы;
    \item $\mathcal{S}$ - окружение; 
    \item $s_{t}$ - $t$-ое состояние окружения: формируется после $t$ действий агента.
\end{itemize}

На практике различные методы обучения политик подразумевает достаточно точную и
строгую формулировку окружения, поскольку по ней выбирается оптимальная политика. 
В нашей задаче это свойство - недостаток, поскольку окружение в лабораториях может 
быть очень вариативным, что затрудняет формализацию.

В подобных случаях можно использовать LLM с указанием инструкций в качестве политики. 
Это понятно почему так: большие модели обучаются на больших массивов данных из Интернета
и других источников, которые содержат в том числе и описательные инструкции как оптимально решать 
типовые задачи. 
Важным ещё является тот факт, что именно указание инструкций в виде входного текста 
формирует то, как именно LLM будет решать поставленные ей задачи 
\cite{plaandsolve, zeroshot-cot, tot}, такое явление называется \textit{``промптингом''}. 
Использование LLM-агента вместо строгоформулируемой политики позволяет отойти 
от строгого описания окружения - теперь окружение описывается в виде текста, 
подаваемого на вход модели. Такое описание окружения вместе с инструкцией принятия решений и 
доступными действиями для решения формируют \textit{'контекст' решаемой задачи}: 
именно через контекст модель понимает, как ей действовать и чем руководствоватся в решении 
переданной задачи. 

Теперь осталось определить, что такое \textit{мультиагентная сеть}.

\subsection{Определение мультиагентная система} \label{ch1:sec1:subsec2}

\textbf{Мультиагентная система} - система, состоящая из нескольких агентов, работающих 
в совокупности для достижения как глобальной, так и общей цели. Система определяется не 
только агентами, входящих в нее, но и регламентами их взаимодействия.

Формально мультиагентную сеть можно определить следующим образом:
\begin{equation}
    MAS = \{Agent_i, i\in\mathcal{N}; \mathcal{C}\} \label{eq2}
\end{equation}
где:
\begin{itemize}
    \item $MAS$ - multi-agent system, непосредственно определяемая система;
    \item $Agent_i$ - агенты-участники системы;
    \item $\mathcal{C}: Agent_i$ х $Agent_j \rightarrow bool$ - политика взаимодействия: 
устанавливает наличие связи между агентами $Agent_i$ и $Agent_j$, $i, j \in \mathcal{N}$.
\end{itemize}
Иногда между агентами требуется не только наличие связи для взаимодействия, но и определить
строго тип взаимодействий: в таком, более общем случае $bool$ заменяется на некоторый тип, 
который имеет свою область определения. 
В рамках работы мультиагентных систем на базе LLM таким типом является 
\textit{текст ('string')} - конечная последовательность символов некоторого алфавита $\Sigma$, 
который, на момент написания работы, как правило состоит из символов латиницы, цифр, знаков
препинания и спецсимволов.

Стоит уделить особое внимание популярному заблуждению, которое возникло за последнее 
время вместе с популяризацией агентов и мультиагентных систем на основе LLM: часто 
``агентами'' называют программные решения, которые не позволяют моделям самостоятельно 
решать как именно действовать. Вместо этого такие системы используют генерацию больших
языковых моделей в качестве некоторого промежуточного решения, которое уже
используют в заранее определенном программно алгоритме \cite{aide}. 
В таких системах нет момента с ``интеллектуальным'' определением дальнейшего действия, 
и такие системы не могут называться ``интеллектуальными агентами''.

Дав определение необходимым терминам, мы можем приступить к постановке задачи. 

\section{Постановка задачи автоматизации процессов при помощи MAS} \label{ch1:sec2}

Необходимо реализовать программное решение, обеспечивающий возможность работы 
пользователя с мультиагентной системой $MAS$ для автоматизации решения 
различных типовых задач, требующих как использование внтреннего инструментария 
лабораторий $\mathcal{A}_{lab}$, так и учитывающих состояния имеющегося окружения 
$\mathcal{S}_{lab}$, с которым этот инструентарий может взаимодействовать:
\begin{equation}\label{eq3}
    MAS = \{Agent_i, i\in\mathcal{N}; \mathcal{C}\};
    Agent_i = \{\mathcal{P}_i, \mathcal{A}_i, \mathcal{S}_i\}
\end{equation}
где:
\begin{itemize}
    \item $\mathcal{P}_i$ - LLM-политика агента $Agent_i$, сформированная видом модели и её 
контекстами;
    \item $\mathcal{A}_i$ - набор действий, доступный агенту $Agent_i$, притом важно, что
$\mathcal{A}_{lab} = \bigcup\limits_{i=1}^N \mathcal{A}_i$;
    \item $\mathcal{S}_i \in \mathcal{S}_{lab}$ - часть окружения $\mathcal{S}_{lab}$, 
с которым необходимо работать инструментарию $\mathcal{A}_i$.
\end{itemize}

Для постановки задачи также необходимо сформировать требования к инструментарию лабораторий.
В рамках рассматриваемой задачи рассматриваются следующие возможные инструменты:
\begin{itemize}
    \item функции для работы с текстом и числами: это обычные инструменты-функции, которые
принимают на вход аргументы в виде текста или чисел, и которые возвращают 
также или текст, или число;
    \item функции, которые работают с данными отличные от текста и чисел;
    \item отдельные фрагменты программных кодов в виде функций, классов и модулей, 
объединенные в группы для совместной работы с целью решения опеделенной задачи 
(например, модуль для обработки специфических данных, класс для отрисовки данных 
и так далее);
    \item готовые целиковые библиотеки, фреймворки, пакеты: как внутренние, так и внешние.
\end{itemize}
Данный набор инструментов охватывает широкий спектр возможных существующих действий: они
неограничены на тип входных и выходных данных, что позволяет более гибко взаимодействовать
с окружением. Сами инструменты могут быть как отдельными функциями, так и частями 
кодовых баз, так и кодовыми базами в виде библиотек целиком. Могут функции работать как
с локальной частью окружения, находящимися в той же среде, что и агент (например, с файлами),
так и с удаленными окружениями посредством обращения через интерфейсы \footnote{возможно, 
стоит переписать}.

